%** {\bf Does all the neyman stuff go in here, or just the examples, with
%   syntax somewhere else?}

%Once matching is complete and balance has been achieved, the \MatchIt\
%object (output from the \texttt{matchit()} function) can be used with
%any other analysis procedure; \MatchIt\ is designed to make those
%analysis procedures less dependent on the modeling assumptions and
%thus work better.  Therefore, any analysis you might have conducted
%using the original data set can be conducted with less model
%dependence using the matched data set.  To obtain the matched data
%set, use {\tt match.data(m.out)}, where {\tt m.out} is a \MatchIt\
%object. See Section~\ref{subsec:match.data} for more options and
%details.

In this section, we describe our recommended approach
\citep{HoImaKin05}, which uses
\hlink{Zelig}{http://gking.harvard.edu/zelig/} to conduct parametric
causal inference after preprocessing the data through \MatchIt.  (The
resulting matched data sets can also be exported to other statistical
programs using commands such as {\tt write.csv()} and {\tt
  write.table()} for ASCII files, and {\tt write.dta} in {\tt foreign}
package for a STATA binary file.)  Zelig \citep{ImaKinLau04} is an
easy-to-use R package that implements a large variety of statistical
models, gives easily interpretable results by simulating quantities of
interest, provides numerical and graphical summaries, and is easily
extensible.  The package along with the complete documentation is
available at
\hlink{http://gking.harvard.edu/zelig/}{http://gking.harvard.edu/zelig/}.
\MatchIt\ and Zelig can be easily used together to enable estimation
of causal effects in very general settings with a variety of
statistical models.

The general syntax is as follows. First, we use \texttt{match.data()}
to create the matched data by excluding unmatched units from the
original data, and including information about the particular matching
procedure (i.e., weights, subclasses, and the distance measure).
\begin{Schunk}
\begin{Sinput}
> m.data <- match.data(m.out)
\end{Sinput}
\end{Schunk}
where {\tt m.out} is the \MatchIt\ object from {\tt matchit()} and
{\tt m.data} is the resulting matched data.  Next, we analyze the
matched data set via the following command,
\begin{Schunk}
\begin{Sinput}
> z.out <- zelig(Y ~ treat + x1 + x2, model = mymodel, data = m.data)
\end{Sinput}
\end{Schunk}
where {\tt Y} is the outcome variable, {\tt mymodel} is the selected
model, and {\tt z.out} is the output object from {\tt zelig}.

To illustrate this approach, we provide several examples using the
Lalonde data. Users can run these example commands by typing {\tt
  demo(Zelig)} at the R prompt. We use the linear least squares model
in these examples. However, a wide range of other models are available
in Zelig (for the list of supported models, see
\hlink{http://gking.harvard.edu/zelig/docs/Models\_Zelig\_Can.html}{http://gking.harvard.edu/zelig/docs/Models_Zelig_Can.html}),
and they can be used in the exactly same way. If you have not
installed Zelig, follow the installation procedure described at
\hlink{http://gking.harvard.edu/zelig/docs/Installation.html}{http://gking.harvard.edu/zelig/docs/Installation.html}

\begin{enumerate}
\item Nearest neighbor matching using propensity scores: 

\begin{Schunk}
\begin{Sinput}
> data(lalonde)
> library(Zelig)
> m.out1 <- matchit(treat ~ age + educ + black + hispan + nodegree + 
+     married + re74 + re75, method = "nearest", data = lalonde)
> z.out1 <- zelig(re78 ~ age + educ + black + hispan + nodegree + 
+     married + re74 + re75 + distance, data = match.data(m.out1, 
+     "control"), model = "ls")
> x.out1 <- setx(z.out1, data = match.data(m.out1, "treat"), fn = NULL, 
+     cond = TRUE)
> s.out1 <- sim(z.out1, x = x.out1)
> summary(s.out1)
\end{Sinput}
\begin{Soutput}

  Model: ls 
  Number of simulations: 1000 

Mean Values of Observed Data (n = 185) 
(Intercept)         age        educ       black      hispan    nodegree 
  1.000e+00   2.582e+01   1.035e+01   8.432e-01   5.946e-02   7.081e-01 
    married        re74        re75    distance 
  1.892e-01   2.096e+03   1.532e+03   5.774e-01 

Pooled Expected Values: E(Y|X)
   mean      sd    2.5%   97.5% 
 4980.4  2293.3   667.7 10025.8 

Pooled Average Treatment Effect: Y - EV
  mean     sd   2.5%  97.5% 
1368.7  592.5  182.1 2499.8 

\end{Soutput}
\end{Schunk}
  
The estimated average treatment effect on the treated is thus 
\$1368.71, 
with a 95\% interval
of (\$182.13, 
\$2499.83).

\item Estimating the average treatment effects on both the treated and
  the control groups. We use the same {\tt matchit()} output as in the
  first example above.

\begin{Schunk}
\begin{Sinput}
> z.out2 <- zelig(re78 ~ age + educ + black + hispan + nodegree + 
+     married + re74 + re75 + distance, data = match.data(m.out1, 
+     "control"), model = "ls")
> x.out2 <- setx(z.out2, data = match.data(m.out1, "control"), 
+     fn = NULL, cond = TRUE)
> s.out2 <- sim(z.out2, x = x.out2)
> ate.all <- c(s.out1$qi$ate.ev, -s.out2$qi$ate.ev)
> mean(ate.all)
\end{Sinput}
\begin{Soutput}
[1] 682.9

\end{Soutput}
\begin{Sinput}
> sd(ate.all)
\end{Sinput}
\begin{Soutput}
[1] 861.5

\end{Soutput}
\begin{Sinput}
> quantile(ate.all, c(0.025, 0.975))
\end{Sinput}
\begin{Soutput}
  2.5%  97.5% 
-723.1 2368.1 

\end{Soutput}
\end{Schunk}
  
\item Subclassification: In this case, the average treatment effect
  estimates are obtained for each subclass separately as well as
  for the overall sample.  Estimating the treatment effects separately 
  for each subclass, and then aggregating across subclasses, can significantly
  increase the robustness of the ultimate results since the paramatric analysis
  within each subclass requires only local rather than global assumptions.

\begin{Schunk}
\begin{Sinput}
> m.out2 <- matchit(treat ~ age + educ + black + hispan + nodegree + 
+     married + re74 + re75, data = lalonde, method = "subclass", 
+     subclass = 4)
> z.out3 <- zelig(re78 ~ re74 + re75 + distance, data = match.data(m.out2, 
+     "control"), model = "ls", by = "subclass")
> x.out3 <- setx(z.out3, data = match.data(m.out2, "treat"), fn = NULL, 
+     cond = TRUE)
> s.out3 <- sim(z.out3, x = x.out3, num = 100)
> summary(s.out3)
\end{Sinput}
\begin{Soutput}

  Model: ls 
  Number of simulations: 25 

Mean Values of Observed Data (n = 46) 
(Intercept)        re74        re75    distance 
     1.0000   5430.5389   2929.0394      0.2392 

Pooled Expected Values: E(Y|X)
 mean    sd  2.5% 97.5% 
 4477  5289 -5154 15745 

Pooled Average Treatment Effect: Y - EV
  mean     sd   2.5%  97.5% 
1873.5 1641.9 -442.5 5423.1 

\end{Soutput}
\begin{Sinput}
> summary(s.out3, subset = 1)
\end{Sinput}
\begin{Soutput}

Results for 1 

  Model: ls 
  Number of simulations: 25 

Mean Values of Observed Data (n = 46) 
(Intercept)        re74        re75    distance 
     1.0000   5430.5389   2929.0394      0.2392 

Pooled Expected Values: E(Y|X)
 mean    sd  2.5% 97.5% 
 6596  3905  2618 17029 

Pooled Average Treatment Effect: Y - EV
  mean     sd   2.5%  97.5% 
 596.3  496.3 -206.8 1429.0 


\end{Soutput}
\begin{Sinput}
> summary(s.out3, subset = 2)
\end{Sinput}
\begin{Soutput}

Results for 1 

  Model: ls 
  Number of simulations: 25 

Mean Values of Observed Data (n = 45) 
(Intercept)        re74        re75    distance 
     1.0000   1777.4221    972.3441      0.6039 

Pooled Expected Values: E(Y|X)
  mean     sd   2.5%  97.5% 
3824.8 2561.6 -358.5 9955.2 

Pooled Average Treatment Effect: Y - EV
  mean     sd   2.5%  97.5% 
2661.5 1447.3  443.4 4797.1 


\end{Soutput}
\begin{Sinput}
> summary(s.out3, subset = 3)
\end{Sinput}
\begin{Soutput}

Results for 1 

  Model: ls 
  Number of simulations: 25 

Mean Values of Observed Data (n = 47) 
(Intercept)        re74        re75    distance 
     1.0000    939.9688   1217.4546      0.6934 

Pooled Expected Values: E(Y|X)
   mean      sd    2.5%   97.5% 
 4169.8  4414.8   340.6 11589.3 

Pooled Average Treatment Effect: Y - EV
  mean     sd   2.5%  97.5% 
1723.6  852.1  289.3 3062.3 


\end{Soutput}
\end{Schunk}
  
%\item Analysis of data from full matching: It will generally not be
%  possible to run models separately within each subclass after full
%  matching, due to very small sample sizes of either the treated or
%  control group within each subclass.  In this situation, a common
%  approach is to run a model with fixed effects included for each of
%  the subclasses.
%
%For example, 
%\begin{verbatim}
%> foo1 <- matchit(treat ~ age + educ + black + hispan + married +
%                nodegree + re74 + re75, data=lalonde, full=T)
%> m1 <- lm(re78~ treat + age + educ + black + hispan + married +
%         nodegree + re74 + re75 + as.factor(psclass),
%         data=foo1$data)
%> summary(m1)
%\end{verbatim} 
\end{enumerate}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "matchit"
%%% End: 
